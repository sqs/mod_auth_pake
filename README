===============================================================================
HTTP Tcpcrypt Authentication
===============================================================================


Session establishment diagram
-------------------------------------------------------------------------------

Definitions
--------------------
h = HMAC(snonce, realm, password)
sid = tcpcrypt sid

Diagram
--------------------
Client                                                   Server

        GET /protected
      -------------------------------------------------->


        HTTP 401
        WWW-Authenticate: Tcpcrypt
                          realm="protected",
                          snonce="123456789"
      <--------------------------------------------------


        GET /protected
        Authorization: Tcpcrypt
                       username="mufasa",
                       realm="protected",
                       snonce="123456789",[1]
                       response=MAC(h, TAG_CLIENT|sid)
                       [2]
      -------------------------------------------------->

        Authentication: Tcpcrypt 
                        response-auth=MAC(h, TAG_SERVER|sid)
      <--------------------------------------------------

Notes
--------------------

[1] Server records the `snonce` given to each client to prevent an attacker from impersonating the real server and obtaining a valid (h, snonce) pair and then re-using those values to compute the authorization response to the real server to log in as the user.

[2] Nonce counter (nc) from HTTP Digest auth is not necessary since tcpcrypt already protects against replay attacks by MAC'ing the tcp packet sequence number.

Known Issues
--------------------
From the tcpcrypt paper, section 4.2:
"The problem is that an attacker who
impersonates the server to obtain the first message can
then mount an offline dictionary attack on the password,
leveraging the single message exchange to guess arbitrar-
ily many passwords. Such an attack may be detectable if
the attacker cannot crack the password in time to mount
a transparent man-in-the-middle attackâ€”but people are
used to clicking reload sometimes when web sites fail
and will not be concerned by a single connection failure."

Initially, HTTP Tcpcrypt Auth only supports weak password authentication, not the stronger variety that uses PAKE (section 4.3 of the tcpcrypt paper).

__END__


Scratch
--------------------

** Is cnonce required? It would help protect against offline dictionary attacks where an impersonating server gets the client to send it MAC(HMAC(snonce, realm, password), TAG_CLIENT|sid), for some `snonce` that the attacker chooses. Then the attacker could mount an offline dictionary attack if it could choose `sid`; can it pick `sid` to be whatever it wants? If so, then a cnonce would be necessary to prevent an offline dictionary attack. If not, then the attacker can't build a dictionary because `sid` would differ for each request. Key question: Can server influence choice of `sid`?

Want to protect against the client guessing server passwords
AND someone impersonating the server for the first response and then
being able to mount an offline dictionary attack and then doing MITM.

Client guessing server passwords
- What protection does salt offer here? They still have to make one
request per login attempt. But suppose an attacker had the user authenticate
to the attacker's "protected" realm. Then the attacker could use the same h
to log into any other server. And suppose the salt were known to the impersonating attacker
server. Then the attacker could use that same salt in his server's WWW-Authenticate 
challenge to the user, and he would then find the correct h to use. So, the salt MUST
differ for each server (be secret), and since people are unlikely to set salts correctly in config files,
it should be randomly generated so that its uniqueness does not rely on configuration.
